# WARNING: Do not EDIT or MERGE this file, it is generated by 'packagespec lock'.
# Include config.mk relative to the repo root (this allows us to invoke this file
# from different directories safely).
include $(shell git rev-parse --show-toplevel)/packages*.lock/config.mk

.PHONY: packages commands build package write-builder-cache-keys \
	write-all-package-cache-keys build-all

GOOS ?= $(shell go env GOOS 2>/dev/null || echo linux)
GOARCH ?= $(shell go env GOARCH 2>/dev/null || echo amd64)

DEFAULT_PACKAGE_YQ := [ .packages[] | select(.inputs.GOOS=="$(GOOS)" and .inputs.GOARCH=="$(GOARCH)") ][0]
QUERY_DEFAULT_PACKAGESPEC = $(call QUERY_LOCK,$(DEFAULT_PACKAGE_YQ) | $(1))

# MK is shorthand for changing to repo root and selecting a make target
# from a file in this directory. All *.mk files in this directory assume
# the current working directory is the repo root. This Makefile exists
# to invoke those mk files correctly.
MK := $(MAKE) -C $(REPO_ROOT) -f $(LOCKDIR)/

# configure load-builder-cache target to load the most specific builder layer cache
# available as an archive in the build cache.

ifneq ($(PACKAGE_SPEC_ID),)

PACKAGE_CACHE_KEY_FILE := $(shell $(call QUERY_PACKAGESPEC,.meta.builtin.PACKAGE_CACHE_KEY_FILE))

# Loading the best available archive for a specific package build.

BUILD_LAYER_ARCHIVES := $(shell $(call QUERY_PACKAGESPEC,.meta.builtin.BUILD_LAYERS[].archive))
BEST_BUILD_LAYER_ARCHIVE := $(shell cd $(REPO_ROOT) && for F in $(BUILD_LAYER_ARCHIVES); do \
	if [ -f $$F ]; then echo $$F; exit 0; fi; done)
ifeq ($(BEST_BUILD_LAYER_ARCHIVE),)
load-builder-cache:
	@echo "No build layer archives found in build cache. Looked for: $(BUILD_LAYER_ARCHIVES)"
else
BEST_BUILD_LAYER_NAME := $(shell $(call QUERY_PACKAGESPEC,.meta.builtin.BUILD_LAYERS[] \
	| select(.archive=="$(BEST_BUILD_LAYER_ARCHIVE)") | .name))
BEST_BUILD_LAYER_LOAD_TARGET := $(BEST_BUILD_LAYER_NAME)-load

load-builder-cache:
	@$(MK)layer.mk $(BEST_BUILD_LAYER_LOAD_TARGET)

endif

else ifneq ($(BUILD_LAYER_ID),)

# Loading the best avilable archive for a specific layer build.

BUILD_LAYER_ARCHIVES := $(shell $(call QUERY_LOCK,.layers[] | select(.name=="$(BUILD_LAYER_ID)") \
	| .meta.builtin.LAYER_LIST[].archive))
BEST_BUILD_LAYER_ARCHIVE := $(shell cd $(REPO_ROOT) && for F in $(BUILD_LAYER_ARCHIVES); do \
	if [ -f $$F ]; then echo $$F; exit 0; fi; done)
ifeq ($(BEST_BUILD_LAYER_ARCHIVE),)

load-builder-cache:
	@echo "No build layer archives found in build cache. Looked for: $(BUILD_LAYER_ARCHIVES)"

else
BEST_BUILD_LAYER_NAME := $(shell $(call QUERY_LOCK,.layers[] | select(.name=="$(BUILD_LAYER_ID)") \
	| .meta.builtin.LAYER_LIST[] | select(.archive=="$(BEST_BUILD_LAYER_ARCHIVE)") | .name))
BEST_BUILD_LAYER_LOAD_TARGET := $(BEST_BUILD_LAYER_NAME)-load

load-builder-cache:
	@$(MK)layer.mk $(BEST_BUILD_LAYER_LOAD_TARGET)

endif

else

load-builder-cache:
	@echo "You must set PACKAGE_SPEC_ID or BUILD_LAYER_ID so we know which caches to look for."

endif


packages:
	@command -v packagespec > /dev/null 2>&1 || { \
		echo "Please install packagespec: 'go get github.com/hashicorp/packagespec/cmd/packagespec'"; \
		echo "Note: packagespec is only available to HashiCorp employees at present."; \
		exit 1; \
	}
	@cd $(REPO_ROOT); packagespec lock -specfile $(SPEC) -lockdir $(LOCKDIR)

commands:
	@$(MAKE) -f packages.mk commands

# build is a convenience target for local builds, do not use in CI.
# Instead, use `make package` specifying PACKAGE_SPEC_ID.
build:
	@echo "==> Building default package for GOOS=$(GOOS) GOARCH=$(GOARCH)"
	@echo "PACKAGE_SOURCE_ID: $(PACKAGE_SOURCE_ID)"
	@ALIASES=$$($(call QUERY_DEFAULT_PACKAGESPEC,.aliases[] | "alias type:\(.type) path:\(.path)") | column -t); \
		echo "$$ALIASES"
	@PACKAGE_SPEC_ID="$$($(call QUERY_DEFAULT_PACKAGESPEC,.packagespecid) | head -n1)"; \
		COMMAND="PACKAGE_SPEC_ID=$$PACKAGE_SPEC_ID $(MK)build.mk package"; \
		echo "$$COMMAND"; \
		$(SHELL) "$$COMMAND"

package:
	@$(MK)build.mk package

write-builder-cache-keys:
	@echo "==> Writing build layer cache keys"
	@$(MK)layer.mk write-cache-keys

write-package-cache-key:
	@if [ -z "$(PACKAGE_CACHE_KEY_FILE)" ]; then echo "Must set PACKAGE_SPEC_ID"; exit 1; fi
	@$(WRITE_PACKAGE_CACHE_KEY)
	@echo "==> Package cache key written: $(PACKAGE_CACHE_KEY_FILE)"

# WRITE_PACKAGE_CACHE_KEY writes the package cache key for PACKAGE_SPEC_ID.
# We reference this as an environment variable, so you can override it in a
# recipe rather than relying on the global setting.
define WRITE_PACKAGE_CACHE_KEY
( \
	cd $(REPO_ROOT); \
	KEY="PACKAGE_SPEC_ID=$$PACKAGE_SPEC_ID"$$'\n'"PACKAGE_SOURCE_ID=$(PACKAGE_SOURCE_ID)"; \
	FILE=$$(yq -r ".packages[] | select(.packagespecid==\"$$PACKAGE_SPEC_ID\") \
		| .meta.builtin.PACKAGE_CACHE_KEY_FILE" < $(LOCK)); \
	echo "$$FILE"; \
	echo "$$KEY"; \
	mkdir -p $$(dirname $$FILE); \
	echo "$$KEY" > "$$FILE";\
)
endef

write-all-package-cache-keys:
	@IDS="$$($(call QUERY_LOCK,.packages[].packagespecid))"; \
	for PACKAGE_SPEC_ID in $$IDS; do \
		$(WRITE_PACKAGE_CACHE_KEY); \
	done; \
	echo "==> All package cache keys written"

clean-builder-images:
	@IMAGES=$$(docker images --format '{{.Repository}}:{{.Tag}}' | grep '^$(BUILDER_IMAGE_PREFIX)' || true); \
		if [ -z "$$IMAGES" ]; then exit 0; fi; \
		docker rmi -f $$IMAGES

clean:
	@cd $(REPO_ROOT); rm -rf $(CACHE_ROOT)

clean-all: clean clean-builder-images

clean-all-prune: clean-all
	docker container prune
	docker image prune

# Configure the releaser repo. If you are developing that repo, you may want
# to clone it adjacent to this one in ../vault-release, otherwise it will
# be cloned into .releaser, if you have access to it.
RELEASER_REPO  := git@github.com:hashicorp/vault-release.git
RELEASER_DIR   := $(REPO_ROOT)/../vault-release
RELEASER_CLONE := NO
RELEASER_PULL  := NO
ifeq ($(shell if [ -d $(RELEASER_DIR) ]; then echo OK; else echo NO; fi),NO)
RELEASER_DIR   := $(REPO_ROOT)/.releaser
RELEASER_CLONE := YES
RELEASER_PULL  := YES
endif

# REQUIRE_EXPORT requires a set of make variables to be nonempty,
# exits 1 if any are not, and exports each one otherwise.
# To be used in recipe bodies.
define REQUIRE_EXPORT
$(foreach VAR,$(1),[ -n "$($(VAR))" ] || { echo "Must set $(VAR)"; exit 1; }; export $(VAR)='$($(VAR))';)
endef

# build-ci triggers a CI build. Note: PRODUCT_REVISION and PRODUCT_VERSION
# must not be set by default for any other target. build-ci is special because
# it calls out to another repo to trigger the build.
# Note: At present, that other repo is only available to HashiCorp employees.
build-ci: PRODUCT_REVISION ?= $(shell git rev-parse HEAD)
build-ci: PRODUCT_VERSION ?= 0.0.0-$(USER)-snapshot
build-ci: RELEASE_SYSTEM_BRANCH ?= $(shell git rev-parse --abbrev-ref HEAD)
build-ci:
	@$(call REQUIRE_EXPORT, \
		PRODUCT_REPO           PRODUCT_PATH           PRODUCT_REVISION \
		PRODUCT_VERSION        PRODUCT_CIRCLECI_SLUG  PRODUCT_CIRCLECI_HOST \
		RELEASE_SYSTEM_BRANCH  SPEC                   LOCKDIR \
	) \
	[ -d "$(RELEASER_DIR)" ] || { \
		[ $(RELEASER_CLONE) = YES ] || { \
			echo "You must clone $(RELEASER_REPO) into $(RELEASER_DIR)"; exit 1; \
		}; \
		echo "==> Attempting to clone $(RELEASER_REPO) into $(RELEASER_DIR)"; \
		echo "==> NOTE: The above repo is only available to HashiCorp employees at this time."; \
		mkdir -p $(RELEASER_DIR); \
		if ! git clone -q "$(RELEASER_REPO)" "$(RELEASER_DIR)"; then \
			echo "==> ERROR: Failed to clone $(RELEASER_REPO)"; \
		fi; \
	}; \
	( \
		cd $(RELEASER_DIR); \
		if [ $(RELEASER_PULL) = YES ]; then \
			git checkout -q master; \
			git pull -q origin master; \
			git clean -qf; \
			git reset -q --hard HEAD; \
		fi; \
		$(MAKE) trigger-product-build; \
	)
